#+TITLE: A Modern Take on Sketchpad
#+STARTUP:nologdone

This isn't really about Sketchpad. I'm just taking the scope of what Sutherland
did as inspiration.

The goal is a duality between the input modes of code and sketching on
canvas. The idea being that if you can see the code your sketch produces, you'll
have an enourmously easier time animating it.

* Goals
** Usability
	 First and foremost this is intended to be usable by non programmers —
	 students, artists, etc. — to produce complex visuals and animations.

	 It needs to support users with no programming ability whatsoever and walk
	 them progressively by concrete example through more and more complex
	 constructions.
** Don't be Processing
	 In particular try to make everything explicite both in the code and in the
	 UI. I don't really want to create a complex UI, but that's going to be
	 necessary I think since we want the barrier to entry to be as low as
	 possible.

	 See (TODO: Remember the name of that essay by Victor and link to it).
* Implementation
** Ramble
	 If I draw a blade of a windmill, I want first and foremost to be able to see
	 the code that produces it:

	 #+BEGIN_SRC clojure
		 (def G__1
			 [::lines [[0 100] [110 400] [230 200]]])
	 #+END_SRC

	 The representation doesn't matter at the moment[fn:1], I just want a name for what
	 I just drew. The becomes especially important when shapes are viewed relative
	 to each other

	 What I need to be able to see to build a complex drawing is how my changes in
	 the GUI effect the code. If I know that copying a shape, rotating, and moving
	 it generates the code:

	 #+BEGIN_SRC clojure
		 (def G__2
			 (->> G__1
						(translate [0 10])
						(rotate 35)))
	 #+END_SRC

	 Then I can infer that to build a four blade turbine I need to:

	 #+BEGIN_SRC clojure
		 (def turbine4
			 (combine
				[G__1
				 (->> G__1
							(translate [0 10])
							(rotate 90))
				 (->> G__1
							(translate [0 10])
							(rotate 180))
				 (->> G__1
							(translate [0 10])
							(rotate 270))]))
	 #+END_SRC

	 A more advanced user should of course be able to see that there is a more
	 general and simpler solution to this problem:

	 #+BEGIN_SRC clojure
		 (defn rot-blade [a]
			 (->> G__1
						(translate [0 10])
						(rotate a)))

		 (defn turbine [n]
			 (combine
				(->> (range 0 360)
						 (filter #(= 0 (mod % (quot 360 n))))
						 rot-blade)))
	 #+END_SRC

	 Now that you have a turbine, you want it to spin. You should infer
	 (correctly!) that calling rotate on the combined turbine will cause the
	 entire thing to spin as you would expect. So it shouldn't be a stretch to
	 infer that the sequence of frames you want in your animation should be:

	 #+BEGIN_SRC clojure
		 (->> (range)
					(filter #(= 0 (mod % 30)))
					(map #(rotate % (turbine 4))))
	 #+END_SRC

	 In principle all you should then need to do is pass that to an `animate` fn.

	 Of course we have an obstacle to get over teaching users to think of ranges
	 and conprehensions as animations. Some simple renaming might be enough to
	 make it substantially easier.

	 I think that sequences (potentially infinite) of frames are more intuitive to
	 people who draw — probably to all non programmers — than mutable
	 canvases. Think Renaissance flip books.

** Considerations
*** Plain ol Cartesian coordinates
		Why is the origin the top left in most graphics programs? Because it was
		easier to implement that way in some particular application or architecture
		and it's just been stuck that way ever since.
*** Looping Like Sonic Pi?
		Given that animation loops are going to execute infinitely in the general
		case — which I expect to be the norm — there will need to be a mechanism in
		place to kill it.

		I think it would be best if the `draw` and `animate` fns, when called, clear
		all current drawings and animations. This will force the user to build
		complex animations by composing frames rather than thinking imperatively of
		many frames at once. And having to keep track of threads of animation.
*** Affine TXs
		What's the most intuitive way to represent affine transformations?
		Defninitely not translate to the origin, rotate, and translate back.

		Every picture should be in it's own normalised form at its own origin,
		compound pictures should be expressed as unions of affine transforms of
		normalised sub pictures. That's the best way I can think of to make my
		pseudo API a reality in any case.
**** Questions
***** Around what do we rotate?
			Logical options are a corner of a bounding box, centre of bounding box, or
			ortocentre of the points in the drawing.

			The centre of the bounding box seems the most logical to me, but if we
			truly want to be general, a rotation should take both a centre and an
			angle. Making the UI reflect that would be trivial.
*** Normalisation
		From the user's point of view, shapes will be either atomic drawings, or
		transformations and compositions of other shapes, but internally this won't
		do.

		I'd like to internally represent drawings as pure data. One way to
		accomplish this would be bitmaps, which are data after all. That would throw
		away a lot of structure though. Remember that a long term goal it to
		automatically recognise when you've drawn something that's almost identical
		to something else — like a not quite straight line, or an off square — and
		suggest fixing it for you. The whole slider that lets the user trade off
		between fidelity of what they drew and simplicity of representation (which
		roughly corresponds to "correctness" or "niceness" of the drawing).

		To this end, some sort of picture normal form is needed. If we relax pixel
		coordinates to be doubles, we can map any shape onto the unit square [0, 1]
		X [0, 1] and store those pixels along with the inverse affine transform. The
		affine transform functions would then act on the affine offset, not on the
		pixels themselves.

		So now we need a canonical order of applying the affine offset info
		(they're noncommutative) but that's easy enough. We have time to look for
		simpler solutions though and should.

		We also need a canonical value for rotation and reflection. The first idea
		that comes to mind is to take the line of best fit of the pixels (either
		filled in or just the raw mouse points) and rotate it so that the line of
		best fit is horizontal. I need to verify that that would be sufficiently
		invariant. For reflection we can insist on there being more points on the
		left than the right, or vice versa.

		This is a heavily researched problem, see
		- [ ] [[https://www.cbica.upenn.edu/sbia/papers/331.pdf][General Affine Invariant Image Normalisation]]
		- [ ] [[http://www.sciencedirect.com/science/article/pii/S0167865504001448][Matching and normalization of affine deformed image from regular moments]]
** Real Symmetry
	 If I create a frame seq as in the ramble section, I should be able to draw
	 the nth frame, and then make changes to it graphically in the editor. Those
	 changes should be reflected in the code.

	 Stumbling block: presumably you don't edit individual frames of an animation,
	 generally speaking, so how should the editor work visual continuity into the
	 picture? I don't have any ideas about this atthe moment, so it's probably
	 best if we just make the user deal with the animations frame by frame at
	 first. I thnk that animators might be used to that. At least as a starting
	 point it's okay.
** UI Considerations
*** Objects
		The way I'm currently thinking about the tool, you'll be able to draw
		individual shapes — maybe every time you hit enter or the space bar it takes
		everything you've drawn and names it as one thing; later on we can worry
		about automatically recognising subparts.

		So how do we worry about the master-instance dichotomy? Really if compound
		drawings are made up of unions affine txs of other drawings, then simply
		replacing the seed var in the pipelines will let us act like we changed a
		master without mutating the master itself.

		So we need several things:

		We need a way to take a canvas, pick out one item from it and enter an
		editing more for just that item.

		When you edit a shape, you should by default be making a new shape derived
		from the old one. These chains of derivation can get arbitrarily long and
		that's part of the power. But at the same time you often want to replace the
		shape you chose with the edited version within the context of the drawing
		that you're making and that should be easily done if not the default. But
		then what happens at the top level? Do we need to worry about keeping a
		sketchbook?

		We need an intuitive way to replace all instances of shape S in drawing D
		with some other shape S'. Syntactically this is just refactoring, so we need
		something IDE-like, but what the hell does this mean graphically?

* Notes
** [2017-04-07 Fri 13:01]
	 Some of the basic editing commands will need to be macros, and I want them to
	 be evaluted from the browser, so I'll need to fully bootstrap cljs.
* Devlog
** Outstanding
*** DONE Affine Transforms [3/3]
		Keep in mind that rotations and scaling all happen about a point. Make that
		point explicit.
		- [X] Rotation about a point
		- [X] Translation
		- [X] Scale
*** TODO New coords
		(0, 0) is the bottom left corner in every math class I've ever heard
		of. It's how basically all graphs do are set and it's how Descartes did
		it. Who the fuck switched it to the top left?
*** TODO Touch events
		Currently canvas events are only implemented for mouse events. Should use
		hammer or whatever is cooler nowadays to get the rest. Probably easier to
		just do it myself though.
*** TODO Dump code for drawing to console
		Temporary workaround until we set up the editor in the browser.
*** TODO Set up repl in the browser
		We want to be able to draw with code directly in the browser.
* Footnotes

[fn:1] And of course you need to be able to change the name and have the editor
handle the change properly.
